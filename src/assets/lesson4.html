<div id="example"></div>
<p>This menu is the demo from the Mithril home page. The code has been
slightly adapted to work with the tutorial. It's a component like any
other. While Header, Content and Footer are nested components under App,
the demo was injected after this page was rendered.</p>

<div class="dothis">Refresh the browser and watch the demo load after
the page is fully rendered.</div>
<div class="dothis">src/components/Demo.coffee</div>

<a href= "http://lhorie.github.io/mithril/mithril.request.html"
target="_blank" class="docs-icon"></a>

<h3>m.request()</h3>
<p>The links in the demo are not hard coded into the component. They need
to be loaded from an outside source. We start by
populating the model with data. <code>m.request()</code>
is Mithril's built-in AJAX wrapper. By default, it expects the resonse to
be in JSON format. See <code class=file>src/assets/pages.json</code></p>
<p>The return value of <code>m.request()</code> is special in 2 ways.
<ul>

  <li>It's a <strong>promise</strong>
<a href= "http://lhorie.github.io/mithril/mithril.deferred.html"
target="_blank" class="docs-icon"></a></li>

  <li>It's an <code>m.prop()</code> getter/setter
  <a href= "http://lhorie.github.io/mithril/mithril.prop.html"
target="_blank" class="docs-icon"></a></li>
</ul>

Our model object (Page) has only one property: <code>list</code>,
whose value is a function that returns the JSON response from the AJAX
request. Demo.controller calls <code>Page.list()</code> and sets the
result to the <code>pages</code> variable.
</p>
<p>An AJAX call is relatively slow, so <code>pages</code> is set to
a promise, an empty placeholder that will be filled as soon as
<code>m.request()</code> returns. This allows the component to start
loading even when it doesn't have all the data. The app feels faster
and more responsive.
</p>
<p><code>pages</code> is also an <code>m.prop()</code> getter/setter function. To retrieve
its value we must call <code>pages()</code> with no parameters. It's
called twice in the view.</p>
<p>App.controller also contains one incredibly useful function:
<code>rotate()</code> ðŸ˜„</p>

<h3>Waiting for a response</h3>
<p>When the view function is called, Mithril will throw an error if
<code>ctrl.pages()</code> returns a null value, so we test it. If <code>m.request()</code>
has returned with a response, we map the JSON to our template.
If there is no response yet: <code>pages&nbsp;===&nbsp;null</code>, we add
<code>m(null)</code> to the template -- which prints nothing.  
</p>

<p>Another important feature of <code>m.request()</code> is that once
it returns with the AJAX response, the view is called again and the
screen is updated with the new data: Our demo starts to appear.</p>

<h3>The Flow</h3>
<p>Lets recap the each step after showDemo is called:
<ul>
<li>Demo is initialized in <code class="file">app.coffee</code></li>
<li>Initialization means that Demo.controller is called</li>
<li>The controller calls the <code>list</code> function in the model (Page)</li>
<li><code>list</code> is an AJAX call which immediately returns an empty promise</li>
<li>The view is called even though <code>list</code> has not returned</li>
<li>The component is rendered to the screen without necessary data</li>
<li>The AJAX call completes then forces a redraw</li>
<li>The redraw fills in the missing data on the screen</li>
</ul>

<p>Two things to note:
<ol>
<li>Controllers only get called once in the life of the component</li>
<li>Views get called every time the component is redrawn</li>
</ol>
</p>


<div class="dothis">Read the comments in
<code class="file">Demo.coffee</code> and
<code class="file">app.coffee</code> and
<code class="file">Content.coffee</code> and
<code class="file">Footer.coffee</code></div>

<hr>

We've now learned enough about Mithril to create a multi page app with
links to individual lessons. We'll put it all together in the next lesson.
This should be the last time you have to do this: